# 15장. 컬렉션 프레임워크
멘토링 날짜 : 16/8/15, 11:00

## 리스트


# 질문
## 스택이나 큐를 만드는 경우 ArrayList? LinkedList?
큐를 배열로 하는 경우 ArrayList.remove(0) 메서드를 계속 호출
따라서, 엄청나게 무거운 작업이 반복되고 내부적으로 계속 복사중
큐는 내부적으로 LinkedList로 구현되어 있음

스택은 내부적으로 ArrayList로 구현되어 있음
따로 메모리할당할 필요가 없어서 더 가벼움

가장 큰 차이점은 인덱싱의 여부
탐색의 경우 LinkedList는 반복적인 루틴을 돌아야하지만,
ArrayList는 인덱스를 통해 빠르게 접근가능

## Set의 장점?
순서를 보장하지 않기 때문에 생성이 빠름
Key 또는 Value를 반환할 때 Set으로 이루어져 있음

## HashMap과 List의 속도비교
검색은 무조건 HashMap이 빠름

### Hash의 내부구조
hashcode()로 바뀌면서 Object를 받을 수 있도록 확장
71942 % 10 = 2
71943 % 10 = 3
연산 이후에 한번 더 위 아래로 이루어져 있음

## HashMap과 HashTable의 차이점
동기화를 보장하는지 안하는지의 차이
수정이라는 작업은 동기화를 걸어주는게 좋지만
운영에 따라서 쓰레드문제가 필요없을수도 있음

## Comparable과 Comparator의 차이점
Comparable은 객체를 비교하는 연산 (파라메터 개수가 하나)
Comparator는 정렬을 위해 비교하는 연산 (파라메터 개수가 두개)

String을 비교할 때도 내부적으로 Comparable이 구현되어 있어서
compareTo 메서드를 통해 비교할 수 있음

## 랭킹 구현하기
100만건 유저 데이터 (Id, score) : Map<User>
Id 이름으로 검색 : Map<User>
상위 100건 랭커 : List<User>
내 순위 가져오기 : Iterator
정렬 : Collections.sort()

Collections.sort()가 빠름
바이트 코드가 아니라 네이티브 코드로 구현이 되어있기 때문 (C언어처럼 주소매핑)

동기화 문제는 어떻게 해결? 스케줄러
요청을 큐에 넣어놨다가 5분 간격으로 랭킹을 업데이트

3번 List는 계속 정렬을 하고
유저의 요청을 받는 List를 따로 만듬
5초 이후에 상위 100건 랭킹과 swap()
이 과정에서 synchronized 설정
원래 있던 List는 백그라운드에서 계속 동작

* read 할 때는 절대 lock을 걸면 안됨
* 하나의 객체에 대해서 필요한 목적에 따라 다양한 자료구조를 사용할 수 있음

'만약에 나는 무조건 실시간으로 보여줘야 한다'라면, OrderedMap을 사용하는 것이 현명
실시간으로 정렬해서 갱신가능
